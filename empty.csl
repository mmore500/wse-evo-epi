// Every PE needs to import memcpy module otherwise the I/O cannot
// propagate the data to the destination.

param memcpy_params: comptime_struct;

// Colors
param ctrl_color: color;

param payload_size: u16;

const rx_iq: input_queue = @get_input_queue(2);
const tx_oq: output_queue = @get_output_queue(2);
const collect_task_id: local_task_id = @get_local_task_id(10);
const do_collect_task_id: local_task_id = @get_local_task_id(11);
const exit_task_id:   local_task_id = @get_local_task_id(9);

const sys_mod = @import_module("<memcpy/memcpy>", memcpy_params);

var result = @zeros([payload_size]u32);
const result_ptr: [*]u32 = &result;

const result_dsd = @get_dsd(
  mem1d_dsd,
  .{ .tensor_access = |i|{payload_size} -> result[i] }
);

const ctrl = @import_module("<control>");

// fabout DSD used to send ctrl wavelet to fabric along tx_color
const tx_ctrl_dsd = @get_dsd(fabout_dsd, .{
  .extent = 1,
  .fabric_color = ctrl_color,
  .control = true,
  .output_queue = tx_oq
});


// main_fn does nothing on recv PEs
fn main_fn() void {

  const in_dsd = @get_dsd(fabin_dsd, .{
    .fabric_color = ctrl_color,
    .extent = payload_size + 1,
    .input_queue = rx_iq
  });
  @mov32(result_dsd, in_dsd, .{
    .async = true,
    // .activate = exit_task_id,
    .on_control = .{ .activate = collect_task_id },
  });
  // sys_mod.unblock_cmd_stream();
  // @assert(false); // TODO: remove this assert when the task is implemented

}

var dummy = @zeros([42]u32);
const dummy_dsd = @get_dsd(
  mem1d_dsd,
  .{ .tensor_access = |i|{42} -> dummy[i] }
);

const tile_config = @import_module("<tile_config>");
const switch_config = tile_config.switch_config;

task collect_task() void {

  switch_config.set_pop_mode(
    ctrl_color,
    switch_config.pop_mode.POP_ON_ADVANCE
  );

  const wait_dsd = @get_dsd(fabin_dsd, .{
    .fabric_color = ctrl_color,
    .extent = 1,
    .input_queue = rx_iq,
  });

  @mov32(dummy_dsd, wait_dsd);  // TODO why an extra (control?) wavelet?
  @mov32(dummy_dsd, wait_dsd, .{
    .async = true,
    .on_control = .{ .activate = do_collect_task_id },
    // .activate = exit_task_id,
  });
}

const layout_module = @import_module("<layout>");

task do_collect_task() void {

  const out_dsd = @get_dsd(fabout_dsd, .{
    .fabric_color = ctrl_color,
    .extent = payload_size,
    .output_queue = tx_oq,
  });
  @mov32(out_dsd, result_dsd, .{
    .async = true,
    .activate = exit_task_id,
  });
}

task exit_task() void {
  const x_coord = layout_module.get_x_coord();
  if (x_coord != 1) {
    const opcodes = [1]ctrl.opcode{
      ctrl.opcode.SWITCH_ADV,
    };
    const ce_ignore = [1]bool{
      true,
    };
    @mov32(
      tx_ctrl_dsd,
      ctrl.encode_payload(
        1, // comptime N: u16,
        opcodes, // comptime cmds: [N]opcode,
        ce_ignore, // comptime ce_ignore: [N]bool,
        true, // ce_ignore_remaining: bool,
        {}, // comptime entrypoint: anytype
      ),
    );
    @mov32(
      tx_ctrl_dsd,
      ctrl.encode_single_payload(ctrl.opcode.SWITCH_ADV, false, {}, 0)
    );
  }
  switch_config.set_pop_mode(
    ctrl_color,
    switch_config.pop_mode.NO_POP,
  );
  switch_config.clear_current_position(ctrl_color);
  sys_mod.unblock_cmd_stream();
}

comptime {
  @bind_local_task(exit_task, exit_task_id);
  @bind_local_task(collect_task, collect_task_id);
  @bind_local_task(do_collect_task, do_collect_task_id);

  @export_symbol(main_fn);

  const broadcast_route = .{
    .rx = .{ EAST, WEST, RAMP },
    .tx = .{ EAST, RAMP }
  };
  const collect_route = .{ .tx = .{ WEST } };
  const activate_route = .{ .tx = .{ RAMP } };
  @set_local_color_config(
    ctrl_color,
    .{
      .routes = broadcast_route,
      .switches = .{
        .pos1 = collect_route,
        .pos2 = activate_route,
        .pos3 = collect_route,
        .current_switch_pos = 0,
        .pop_mode = .{ .no_pop = true },
        .ring_mode = false,
      },
      // .filter = .{
      //   .kind = .{ .counter = true },
      //   .count_data = false,
      //   .count_control = true,
      //   .init_counter = 0,
      //   .max_counter = 1,
      //   .limit1 = 1,
      //   .filter_control = true,
      // },
    }
  );

  @export_symbol(result_ptr, "result");
}
