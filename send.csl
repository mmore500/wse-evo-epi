// WSE-2 task ID map
// On WSE-2, data tasks are bound to colors (IDs 0 through 24)
//
//  ID var                ID var   ID var                ID var
//   0                     9       18                    27 reserved (memcpy)
//   1                    10       19                    28 reserved (memcpy)
//   2                    11       20                    29 reserved
//   3                    12       21 reserved (memcpy)  30 reserved (memcpy)
//   4                    13       22 reserved (memcpy)  31 reserved
//   5                    14       23 reserved (memcpy)  32
//   6                    15       24                    33
//   7                    16       25                    34
//   8                    17       26                    35

param memcpy_params: comptime_struct;

// Colors
param ctrl_color: color;

// Queues
const tx_oq: output_queue = @get_output_queue(2);

const sys_mod = @import_module("<memcpy/memcpy>", memcpy_params);
const ctrl = @import_module("<control>");
const layout_module = @import_module("<layout>");

// fabout DSD used to send ctrl wavelet to fabric along ctrl_color
const tx_ctrl_dsd = @get_dsd(fabout_dsd, .{
  .extent = 1,
  .fabric_color = ctrl_color,
  .control = true,
  .output_queue = tx_oq
});

fn main_fn() void {
  // ID of control task activated on receivers
  const recv_ctrl_id = @get_control_task_id(40);

  // Now we can reuse a single color to send data to the four neighbors of this PE.
  // We forward the payload of this control wavelet to the CE, where the ctrl task
  // bound to recv_ctrl_id will be activated. data argument is 16-bit arg of ctrl task.
  const y_coord = layout_module.get_y_coord();

  for (@range(u16, 100)) |i| {
  @mov32(
    tx_ctrl_dsd,
    ctrl.encode_single_payload(ctrl.opcode.NOP, false, recv_ctrl_id, y_coord)
  );
  }

  sys_mod.unblock_cmd_stream();
}

comptime {
  @export_symbol(main_fn);

  const main_route = .{ .rx = .{ RAMP }, .tx = .{ EAST } };
  @set_local_color_config(ctrl_color, .{ .routes = main_route });

}
