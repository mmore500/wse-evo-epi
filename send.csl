// WSE-2 task ID map
// On WSE-2, data tasks are bound to colors (IDs 0 through 24)
//
//  ID var                ID var   ID var                ID var
//   0                     9       18                    27 reserved (memcpy)
//   1                    10       19                    28 reserved (memcpy)
//   2                    11       20                    29 reserved
//   3                    12       21 reserved (memcpy)  30 reserved (memcpy)
//   4                    13       22 reserved (memcpy)  31 reserved
//   5                    14       23 reserved (memcpy)  32
//   6                    15       24                    33
//   7                    16       25                    34
//   8                    17       26                    35

param memcpy_params: comptime_struct;

// Colors
param ctrl_color: color;

param payload_size: u16;

param collect_count: u16;

// Queues
const tx_oq: output_queue = @get_output_queue(2);
const rx_iq: input_queue = @get_input_queue(2);
const exit_task_id:   local_task_id = @get_local_task_id(9);
const collect_task_id: local_task_id = @get_local_task_id(10);

const sys_mod = @import_module("<memcpy/memcpy>", memcpy_params);
const ctrl = @import_module("<control>");
const layout_module = @import_module("<layout>");


// fabout DSD used to send ctrl wavelet to fabric along tx_color
const tx_ctrl_dsd = @get_dsd(fabout_dsd, .{
  .extent = 1,
  .fabric_color = ctrl_color,
  .control = true,
  .output_queue = tx_oq
});

// fabout DSD used to send ctrl wavelet to fabric along ctrl_color
const out_dsd = @get_dsd(fabout_dsd, .{
  .extent = payload_size,
  .fabric_color = ctrl_color,
  .output_queue = tx_oq
});

// fabin DSD
const in_dsd = @get_dsd(fabin_dsd, .{
  .fabric_color = ctrl_color,
  .extent = payload_size * collect_count,
  .input_queue = rx_iq
});

var bcst = @zeros([payload_size]u32);
var bcst_dsd = @get_dsd(
  mem1d_dsd,
  .{ .tensor_access = |i|{payload_size} -> bcst[i] }
);

var coll = @zeros([payload_size * collect_count]u32);
var coll_dsd = @get_dsd(
  mem1d_dsd,
  .{ .tensor_access = |i|{payload_size * collect_count} -> coll[i] }
);

fn main_fn() void {
  const y_coord = layout_module.get_y_coord();

  for (@range(u16, payload_size)) |i| { bcst[i] = @as(u32, y_coord + i); }

  @mov32(out_dsd, bcst_dsd, .{ .async = true, .activate = collect_task_id });

}

task collect_task() void {
  // switch all routers to collect mode
  @mov32(
    tx_ctrl_dsd,
    ctrl.encode_single_payload(ctrl.opcode.SWITCH_ADV, false, {}, 0)
  );
  @mov32(
    coll_dsd,
    in_dsd,
    .{
      .async = true,
      .activate = exit_task_id,
    },
  );
}

task exit_task() void {
  sys_mod.unblock_cmd_stream();
}

comptime {
  @export_symbol(main_fn);
  @bind_local_task(collect_task, collect_task_id);
  @bind_local_task(exit_task, exit_task_id);

   const broadcast_route = .{
    .rx = .{ EAST, RAMP },
    .tx = .{ EAST }
  };
  const collect_route = .{ .tx = .{ RAMP } };
  @set_local_color_config(
    ctrl_color,
    .{
      .routes = broadcast_route,
      .switches = .{
        .pos1 = collect_route,
        .current_switch_pos = 0,
        .pop_mode = .{ .no_pop = true },
        .ring_mode = true,
      },
    }
  );

}
