// WSE-2 task ID map
// On WSE-2, data tasks are bound to colors (IDs 0 through 24)
//
//  ID var                ID var  ID var                ID var
//   0                     9      18                    27 reserved (memcpy)
//   1                    10      19                    28 reserved (memcpy)
//   2                    11      20                    29 reserved
//   3                    12      21 reserved (memcpy)  30 reserved (memcpy)
//   4                    13      22 reserved (memcpy)  31 reserved
//   5                    14      23 reserved (memcpy)  32
//   6                    15      24                    33
//   7                    16      25                    34
//   8                    17      26                    35
//   ...
//  40 recv_ctrl_id


param memcpy_params: comptime_struct;

param payload_size: u16;

// Colors
param ctrl_color: color;

const rx_iq: input_queue = @get_input_queue(2);

// Task IDs
var result = @zeros([payload_size]u32);
const result_ptr: [*]u32 = &result;

const result_dsd = @get_dsd(
  mem1d_dsd,
  .{ .tensor_access = |i|{payload_size} -> result[i] }
);

const sys_mod = @import_module("<memcpy/memcpy>", memcpy_params);

// main_fn does nothing on recv PEs
fn main_fn() void {

  const in_dsd = @get_dsd(fabin_dsd, .{
    .fabric_color = ctrl_color,
    .extent = payload_size,
    .input_queue = rx_iq
  });
  @mov32(result_dsd, in_dsd);

  sys_mod.unblock_cmd_stream();
}

comptime {
  // Since there is no data task receiving wlts along ctrl_color, color/ queue
  // must be explicitly unblocked for CE to receive and ctrl task to be activated
  // On WSE-2, we unblock color. On WSE-3, we unblock queue to which color is bound
  @unblock(ctrl_color);

  @export_symbol(result_ptr, "result");
  @export_symbol(main_fn);

  const main_route = .{ .rx = .{ WEST }, .tx = .{ RAMP } };
  @set_local_color_config(ctrl_color, .{ .routes = main_route });

}
